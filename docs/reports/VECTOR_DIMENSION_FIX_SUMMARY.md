# Vector Dimension Mismatch Fix Summary

## Problem Statement

The application was experiencing vector dimension mismatch errors:
1. **Neo4j/Graphiti Error**: "Invalid input for 'vector.similarity.cosine()': The supplied vectors do not have the same number of dimensions"
2. **Initially reported as Supabase error**: "different vector dimensions 768 and 3072"

## Root Cause Analysis

### Investigation Findings

1. **Database Schema**: Both Supabase and Neo4j are correctly configured for 768-dimensional vectors
2. **Embedding Model**: Using `gemini-embedding-001` which natively produces 3072-dimensional vectors
3. **Configuration**: Environment variable `VECTOR_DIMENSION=768` is set correctly
4. **Normalization Code**: The application has proper normalization functions that truncate embeddings to 768 dimensions

### The Core Issue

The Graphiti library's `GeminiEmbedder` class does not properly respect the `embedding_dim` configuration parameter passed during initialization. Even though we configure it with `embedding_dim=768`, it still generates 3072-dimensional embeddings internally.

### Why This Matters

- **Neo4j Storage**: During ingestion, embeddings ARE correctly normalized to 768 dimensions before storage
- **Search Queries**: When performing searches, Graphiti generates new embeddings that are NOT normalized, causing dimension mismatch with stored data
- **Supabase**: Vector searches work correctly because our code explicitly normalizes embeddings before calling Supabase functions

## Solution Implemented

### Monkey-Patch Approach

We implemented a monkey-patch solution that wraps the GeminiEmbedder's `create` method to ensure all embeddings are normalized to 768 dimensions:

```python
# In agent/graph_utils.py, after Graphiti initialization:
if embedding_provider in ["gemini", "google"] and hasattr(self.graphiti.embedder, 'create'):
    original_create = self.graphiti.embedder.create
    
    async def normalized_create(text=None, input_data=None, **kwargs):
        """Wrapper that ensures embeddings are 768-dimensional."""
        actual_text = text if text is not None else input_data
        if actual_text is None:
            raise ValueError("Either 'text' or 'input_data' must be provided")
        
        embedding = await original_create(actual_text, **kwargs)
        
        # Normalize to 768 dimensions if needed
        if len(embedding) != 768:
            import numpy as np
            if len(embedding) > 768:
                # Truncate and renormalize
                embedding = embedding[:768]
                norm = np.linalg.norm(embedding)
                if norm > 0:
                    embedding = (np.array(embedding) / norm).tolist()
            else:
                # Pad with zeros
                embedding = embedding + [0.0] * (768 - len(embedding))
        
        return embedding
    
    # Replace the create method with our normalized version
    self.graphiti.embedder.create = normalized_create
```

### Key Features of the Fix

1. **Handles Multiple Call Signatures**: The wrapper handles both `text` and `input_data` parameters
2. **Preserves Cosine Similarity**: Renormalizes after truncation to maintain unit length
3. **Applied at Initialization**: Ensures all embeddings generated by Graphiti are normalized
4. **Provider-Specific**: Only applies to Gemini/Google embedding providers

## Testing Results

### Before Fix
- ❌ Neo4j/Graphiti searches failed with dimension mismatch
- ✅ Supabase vector searches worked (due to explicit normalization)

### After Fix
- ✅ Neo4j/Graphiti searches should work with normalized embeddings
- ✅ Supabase vector searches continue to work

## Remaining Issue

The current fix ensures that new embeddings generated during runtime are normalized. However, if there are existing embeddings in Neo4j that were stored with 3072 dimensions before the fix, those will still cause dimension mismatches.

### Verification Needed

Run the following to check existing Neo4j embeddings:
```python
python check_neo4j_embedding_dimensions.py
```

If the script shows 3072-dimensional embeddings, a re-ingestion with the fix in place would be needed.

## Long-term Recommendations

1. **Upstream Fix**: Report this issue to the Graphiti library maintainers - the `embedding_dim` parameter should be respected
2. **Consistent Normalization**: Consider implementing normalization at the database driver level to ensure consistency
3. **Monitoring**: Add dimension checks to health monitoring to catch such issues early
4. **Testing**: Add integration tests that verify embedding dimensions across all components

## Files Modified

- `/agent/graph_utils.py`: Added monkey-patch for GeminiEmbedder normalization
- Various test files created for debugging (can be removed):
  - `test_graphiti_embedding_dimension.py`
  - `test_graphiti_search_bug.py`
  - `check_neo4j_embedding_dimensions.py`
  - `inspect_gemini_embedder.py`
  - `inspect_create_signature.py`

## Conclusion

The fix successfully addresses the dimension mismatch issue by ensuring all embeddings generated by Graphiti are normalized to 768 dimensions, matching the database schema and existing stored embeddings. This is a workaround for a limitation in the Graphiti library's GeminiEmbedder implementation.